#!/usr/bin/env python3

import argparse
import hashlib
import json
import os
import re

import requests

REGISTRY = 'https://docker-registry.wikimedia.org'
BASE_DIR = os.path.dirname(__file__)
FOOTER = '''
<footer>
    <div id="powered-by">
        <a href="/"><img src="https://tools-static.wmflabs.org/toolforge/banners/Powered-by-Toolforge.png" alt="Powered by Wikimedia Toolforge"></a>
    </div>
    <a id="source" href="https://github.com/thcipriani/dockerregistry">view source</a>
</footer>
</body>
</html>
'''

HEADER_FMT = '''
<!doctype html5>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Wikimedia Docker - Image: {image}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="{top_dir}/style.css" type="text/css" />
</head>
<body>
    <h1><a href="{top_dir}">Wikimedia Docker</a> - Image: {image}</h1>
'''


FOOTER = '''
<footer>
    <div id="powered-by">
        <a href="/"><img src="https://tools-static.wmflabs.org/toolforge/banners/Powered-by-Toolforge.png" alt="Powered by Wikimedia Toolforge"></a>
    </div>
    <a id="source" href="https://github.com/thcipriani/dockerregistry">view source</a>
</footer>
</body>
</html>
'''


def make_tag(tag):
    """
    Output html for a tag
    """
    return '<li>' + tag + '</li>'

def make_tag_group(date_created, tags):
    """
    Output grouped html for a list of tags
    """
    return '<div class="tag-group">\n<h3>{}</h3>\n<ul>{}</ul>\n</div>'.format(date_created, '\n'.join(tags))

def render_html_tags(tags):
    """
    Output html page for an image
    """
    image = tags['name']
    image_base = os.path.join(BASE_DIR, image, 'tags')
    top_dir = os.path.relpath(BASE_DIR, image_base)

    # os.mkdirs(image_base)

    # image_index = os.path.join(image_base, 'index.html')

    print(HEADER_FMT.format(
        top_dir=top_dir,
        image=image
    ))

    latest_created_date = sorted(tags['tags'], reverse=True)[0]
    latest_tag = tags['tags'][latest_created_date][0]
    latest_image = '{}:{}'.format(REGISTRY, latest_tag)

    print('<div class="download"><h2>Download:</h2><code><pre>docker pull {}</pre></code></div>'.format(
        latest_image
    ))

    print('<div class="tags"><h2>Tags:</h2>')
    for date_created, tag_list in sorted(tags['tags'].items(), reverse=True):
        print(make_tag_group(date_created, [make_tag(tag) for tag in tag_list]))

    print('</div>')

    print(FOOTER)

class DockerRegistry(object):
    def __init__(self, url, version='v2'):
        self.registry = url
        self.version = version
        self._pagination_re = re.compile('<([^>]*)>')

    def _query_repo(self, endpoint):
        base_path = self.registry

        if not endpoint.startswith('v2'):
            base_path = os.path.join(self.registry, self.version)

        r = requests.get(os.path.join(base_path, endpoint))
        r.raise_for_status()
        return r

    def _extract_resource(self, response, resource):
        return response.json().get(resource)

    def _page_query(self, query, resp_list, fn_argv='', function_name=None):
        if not function_name:
            function_name = self._extract_resource
        response = self._query_repo(query)
        resp_list += function_name(response, fn_argv)

        # Docker registry paginates and sends continuation header 'Link'
        next_link = self._extract_header(response, 'link')

        if not next_link:
            return resp_list

        page = self._pagination_re.search(next_link)
        page = page.group(1)
        if page.startswith('/'):
            return self._page_query(page[1:], resp_list)

        return self._page_query(page, resp_list)

    def get_repos(self):
        repos = []
        return self._page_query('_catalog', repos)

    def _extract_header(self, response, header):
        return response.headers.get(header)

    def __getitem__(self, image):
        tags = []
        tags_with_digest = {}
        self._page_query(os.path.join(image, 'tags', 'list'), tags, 'tags')
        for tag in tags:
            digests = []
            self._page_query(os.path.join(image, 'manifests', tag), digests, 'history', self._extract_resource)
            tag_created = json.loads(digests[0]['v1Compatibility'])['created']
            tags_with_digest.setdefault(tag_created, []).append(tag)
        return {'name': image, 'tags': tags_with_digest}

def parse_args():
    ap = argparse.ArgumentParser()
    g = ap.add_mutually_exclusive_group(required=True)
    g.add_argument('--repos', action='store_true')
    g.add_argument('--image-tags', metavar='IMAGE_NAME')
    ap.add_argument('--output-type', default='console')
    return ap.parse_args()

def main():
    args = parse_args()
    registry = DockerRegistry(REGISTRY)
    if args.repos:
        print('\n'.join(registry.get_repos()))
        return 0
    tags = registry[args.image_tags]
    if args.output_type == 'console':
        print(json.dumps(tags))
    else:
        return render_html_tags(tags)
    return 0

if __name__ == '__main__':
    main()
