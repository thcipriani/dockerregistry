#!/usr/bin/env python3

import argparse
import hashlib
import json
import os
import re

import requests

BASE_DIR = os.path.dirname(__file__)
FOOTER = '''
<footer>
    <div id="powered-by">
        <a href="/"><img src="https://tools-static.wmflabs.org/toolforge/banners/Powered-by-Toolforge.png" alt="Powered by Wikimedia Toolforge"></a>
    </div>
    <a id="source" href="https://github.com/thcipriani/dockerregistry">view source</a>
</footer>
</body>
</html>
'''

HEADER_FMT = '''
<!doctype html5>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Wikimedia Docker - Image: {image}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="{top_dir}/style.css" type="text/css" />
</head>
<body>
    <h1><a href="{top_dir}">Wikimedia Docker</a> - Image: {image}</h1>
'''


def render_html_tags(tags):
    """
    Output html page for an image
    """
    image = tags['name']
    image_base = os.path.join(BASE_DIR, image, 'tags')
    top_dir = os.path.relpath(BASE_DIR, image_base)

    # os.mkdirs(image_base)

    # image_index = os.path.join(image_base, 'index.html')

    print(HEADER_FMT.format(
        top_dir=top_dir,
        image=image
    ))
    for _, tag_list in tags['tags'].items():
        print(tag_list)



class DockerRegistry(object):
    def __init__(self, url, version='v2'):
        self.registry = url
        self.version = version
        self._pagination_re = re.compile('<([^>]*)>')

    def _query_repo(self, endpoint):
        base_path = self.registry

        if not endpoint.startswith('v2'):
            base_path = os.path.join(self.registry, self.version)

        r = requests.get(os.path.join(base_path, endpoint))
        r.raise_for_status()
        return r

    def _extract_resource(self, response, resource):
        return response.json().get(resource)

    def _page_query(self, query, resp_list, fn_argv='', function_name=None):
        if not function_name:
            function_name = self._extract_resource
        response = self._query_repo(query)
        resp_list += function_name(response, fn_argv)

        # Docker registry paginates and sends continuation header 'Link'
        next_link = self._extract_header(response, 'link')

        if not next_link:
            return resp_list

        page = self._pagination_re.search(next_link)
        page = page.group(1)
        if page.startswith('/'):
            return self._page_query(page[1:], resp_list)

        return self._page_query(page, resp_list)

    def get_repos(self):
        repos = []
        return self._page_query('_catalog', repos)

    def _extract_header(self, response, header):
        return response.headers.get(header)

    def __getitem__(self, image):
        tags = []
        tags_with_digest = {}
        self._page_query(os.path.join(image, 'tags', 'list'), tags, 'tags')
        for tag in tags:
            digests = []
            self._page_query(os.path.join(image, 'manifests', tag), digests, 'fsLayers', self._extract_resource)
            md5sum = hashlib.md5()
            md5sum.update(''.join([repr(x) for x in digests]).encode('utf8'))
            digest_md5 = md5sum.hexdigest()
            tags_with_digest.setdefault(digest_md5, []).append(tag)
        return {'name': image, 'tags': tags_with_digest}

def parse_args():
    ap = argparse.ArgumentParser()
    g = ap.add_mutually_exclusive_group(required=True)
    g.add_argument('--repos', action='store_true')
    g.add_argument('--image-tags', metavar='IMAGE_NAME')
    ap.add_argument('--output-type', default='console')
    return ap.parse_args()

def main():
    args = parse_args()
    registry = DockerRegistry('https://docker-registry.wikimedia.org')
    if args.repos:
        print('\n'.join(registry.get_repos()))
        return 0
    tags = registry[args.image_tags]
    if args.output_type == 'console':
        print(json.dumps(tags))
    else:
        return render_html_tags(tags)
    return 0

if __name__ == '__main__':
    main()
